### 41\. Путь к файлу

Любой файл имеет адрес или путь. 

На Linux и macOS путь может выглядеть так:
`
/Users/joe/file.txt
`

А на Windows так:
`
C:\\Users\\joe\\file.txt
`

Следует быть очень внимательным при работе с путями в приложении, поскольку это может иметь решающее значение. 

Соответствующий модуль подключается следующим образом:
`
const path = require('path')
`

После этого его можно использовать. 

##### Получение информации из path

Для извлечения информации из пути используются следующие методы:

* dirname - директория, в которой находится файл
* basename - название файла
* extname - расширение файла

Например:

	const notes = '/Users/joe/notes.txt'

	path.dirname(notes) // /Users/joe 
	path.basename(notes) // notes.txt 
	path.extname(notes) // .txt 

Вы можете получить название файла без расширения:
`
path.basename(notes, path.extname(notes)) // notes 
`

##### Работа с путями

Вы можете соединить две или более части пути посредством path.join():
`
const name = 'joe'
path.join('/', 'Users', name, 'notes.txt')
`

Абсолютный путь файла на основе относительного можно получить с помощью path.resolve():
`
path.resolve('joe.txt') // '/Users/joe/joe.txt'
`

В данном случае, Node.js просто добавляет /joe.txt к адресу текущей (рабочей) директории. Если вы определите первый параметр - директорию, resolve использует ее как основу для второго параметра - файла:
`
path.resolve('tmp', 'joe.txt') // '/Users/joe/tmp/joe.txt'
`

Если первый параметр начинается со слеша - это абсолютный путь: 
`
path.resolve('/etc', 'joe.txt') // '/etc/joe.txt'
`

Еще одной полезной функцией является path.normalize(), которая пытается вычислить актуальный путь на основе относительных спецификаторов типа ., .. или двойного слеша:
`
path.normalize('/Users/joe/..//test.txt') // /Users/test.txt
`

resolve и normalize не проверяют, существует ли путь на самом деле. Они лишь вычисляют путь на основе полученной информации.

