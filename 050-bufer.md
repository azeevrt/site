### 50\. Буфер

##### Что такое буфер?

Буфер - это место в памяти. JavaScript-разработчики не знакомы с этой концепцией, по крайней мере, они знакомы с ней намного хуже, чем разработчики, пишущие код на C, C++ и Go, которые работают с памятью каждый день. 

Буфер представляет собой фиксированный раздел памяти (размер которого можно изменять), находящийся за пределами движка JavaScript V8\. 

Вы можете думать о буфере как о массиве целых чисел, где каждое число - это байт данных. 

В Node.js буфер реализован [классом Буфер][anchor0]. 

##### Зачем нужен буфер?

Буферы были представлены для облегчения работы с двоичными данными, в экосистеме, где присутствовали лишь строки. 

Буферы тесно связаны с потоками. Когда процессор потока получает данные быстрее, чем он может их преобразовать, данные помещаются в буфер. 

Простой визуализацией буфера является просмотр видео на YouTube, когда видео загружается быстрее, чем просматривается: в этом случае загруженное видео помещается в буфер. 

##### Как создать буфер?

Буферы создаются с помощью методов Buffer.from(), Buffer.alloc() и Buffer.allocUnsafe(). 
`
const buf = Buffer.from('Hey!')
`

* Buffer.from(array)
* Buffer.from(arrayBuffer\[, byteOffset\[, length\]\])
* Buffer.from(buffer)
* Buffer.from(string\[, encoding\])

Вы также можете инициализировать буфер, передав размер в качестве аргумента. Вот как создать буфер размером 1 Кб:
`
const buf = Buffer.alloc(1024)
// или 
const buf = Buffer.allocUnsafe(1024)
`

Оба метода, alloc и allocUnsafe создают буфер определенного размера в байтах, однако Buffer, созданный с помощью alloc будет инициализирован с нулями, а Buffer, созданный с помощью allocUnsafe не будет инициализирован. Это означает, что allocUnsafe производительнее, чем alloc, но в выделяемой им памяти могут храниться старые данные. 

При чтении буфера может произойти утечка старых (перезаписанных) данных. Вот что делает allocUnsafe небезопасным. Поэтому при его использовании следует быть крайне осторожным. 

##### Использование буфера

###### Получение содержимого буфера

Доступ к буферу, представляющему собой массив байтов, можно получить как к любому массиву:
`
const buf = Buffer.from('Hey!')
console.log(buf[0]) // 72
console.log(buf[1]) // 101
console.log(buf[2]) // 121
`

Эти числа представляют собой кодовые обозначения символов переданной строки (H =\> 72, e =\> 101, y =\> 121). 

Увидеть содержимое буфера можно с помощью метода toString(): 
`
console.log(buf.toString())
`

Если вы инициализировали буфер с помощью числа - размера буфера, вы получите доступ к подготовленному разделу памяти, содержащему произвольные данные, т.е. буфер не будет пустым. 

###### Получение длины буфера

Используйте свойство length: 
`
const buf = Buffer.from('Hey!')
console.log(buf.length)
`

###### Перебор содержимого буфера
`
const buf = Buffer.from('Hey!')
for (const i of buf) {
    console.log(i) // 72 101 121 33
}
`

###### Именение содержимого буфера

Вы можете записать в буфер строку данных посредством метода write(): 
`
const buf = Buffer.alloc(4)
buf.write('Hey!')
`

Записывать данные в буфер также можно с помощью скобочной нотации: 
`
const buf = Buffer.from('Hey!')
buf[1] = 111 // o 
console.log(buf.toString()) // Hoy!
`

###### Копирование буфера

Копировать буфер можно с помощью метода copy():
`
const buf = Buffer.from('Hey!')
let bufcopy = Buffer.alloc(4) // выделяем 4 байта
buf.copy(bufcopy)
`

###### Получение части буфера

Если вы хотите получить часть буфера, то можете сделать срез (slice). Срез - это не копия, оригинальный буфер - источник истины для него, поэтому при изменении оригинального буфера изменится и срез. 

Для создания среза используйте метод slice(). Первый параметр - начальная позиция, второй (опциональный) - конечная позиция: 
`
const buf = Buffer.from('Hey!')
buf.slice(0).toString() // Hey!
const slice = buf.slice(0, 2)
console.log(slice.toString()) // He
buf[1] = 111 // o
console.log(slice.toString()) // Ho
`

[anchor0]: https://nodejs.org/api/buffer.html

