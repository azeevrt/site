### 51\. Поток

##### Что такое поток?

Поток - одна из главных причин высокой производительности Node.js-приложений. 

Это способ чтения/записи файлов, работы с сетью или любого другого обмена информацией между конечными устройствами. 

Потоки не являются уникальными для Node.js. Они появились в операционных системах семейства Unix, программы могут взаимодействовать друг с другом с помощью потоков через оператор "pipe" (|). 

Например, когда вы указываете программе прочитать файл, файл считывается в память от начала до конца, затем вы его обрабатываете. 

Потоки позволяют читать и обрабатывать файл по частям без его помещения в память. 
Node.js предоставляет [модуль поток][anchor0]. Все потоки являются экземплярами EventEmitter. 

##### Почему потоки?

Потоки по сравнению с другими способами получения данных обладают двумя главными преимуществами:

* эффективное использование памяти: вам не нужно загружать все данные в память перед их использованием
* повышение производительности: данные можно использовать сразу, не дожидаясь окончания их получения

##### Пример потока

Типичным примером использования потока является чтение файла с диска. 

Данные можно прочитать с помощью модуля fs и отправить в ответе при установлении соединения с сервером: 

    const http = require('http')
    const fs = require('fs')

    cnst server = http.createServer((req, res) => {
        fs.readFile(__dirname + '/data.txt', (err, data) => {
            res.end(data)
        })
    })
    server.listen(3000)


readFile() читает содержимое файла и вызывает колбек. 

res.end(data) - это колбек, возвращающий содержимое файла клиенту. 

Если файл является большим, данная операция займет много времени. Вот тот же пример с использованием потоков: 

    const http = require('http')
    const fs = require('fs')

    const server = http.createServer((req, res) => {
        const stream = fs.createReadStream(__dirname + '/data.txt')
        stream.pipe(res)
    })
    server.listen(3000)

Теперь, вместо того, чтобы ждать завершения чтения файла, мы начинаем отправлять его клиенту по частям сразу после получения очередной порции. 

##### pipe()

В приведенном примере имеется строка stream.pipe(res): в потоке вызывается метод pipe(). 

Что делает этот код? Он получает ресурсы и создает тоннель к пункту назначения. 

Мы вызываем его в потоке, поэтому в данном случае происходит туннелирование в HTTP-ответ. 

Метод pipe() возвращает поток к пункту назначения, что позволяет создавать цепочки из вызовов pipe(): 
`
src.pipe(dest1).pipe(dest2)
`

Данная консрукция аналогична следующей:
`
src.pipe(dest1)
dest1.pipe(dest2)
`

##### Прикладные интерфейсы Node.js, поддерживающие потоки

Из-за преимуществ, предоставляемых потоками, многие модули ядра Node.js поддерживают работу с ними: 

* process.stdin - возвращает поток к устройству ввода
* process.stdout - возвращает поток к устройству вывода
* process.stderr - возвращает поток к устройству обработки ошибок
* fs.createReadStream() - создает поток для чтения файла
* fs.createWritableStream() - создает поток для записи файла
* net.connect() - инициализирует основанное на потоках соединение
* http.request() - возвращает экземпляр класса http.ClientRequest, который является потоком для записи
* zlib.createGzip() - сжимает данные с помощью gzip (алгоритм сжатия) внутри потока
* zlib.createGunzip() - разворачивает сжатый (gzip) поток
* zlib.createDeflate() - сжимает данные с помощью deflate (алгоритм сжатия) внутри потока
* zlib.createInflate() - разворачивает сжатый (deflate) поток

##### Типы потоков

Существует 4 класса потоков: 

* для чтения (readable): поток, который может служить началом тоннеля, но не его концом (т.е. мы можем получать данные из потока, но не записывать их в него). При записи данных в такой поток, они помещаются в буфер и находятся там до тех пор, пока не будут прочитаны
* для записи (writable): поток, который может служить концом тоннеля, но не его началом (т.е. мы можем записывать данные в такой поток, но не получать их из него)
* дуплексные (duplex): двунаправленный поток, обычно, является комбинацией потоков для чтения и записи
* трансформирующиеся (transform): такие потоки похожи на дуплексные, однако точкой их выхода является преобразованная точка входа

##### Как создать поток для чтения?

Поток для чтения предоставляется модулем поток, мы инициализируем и реализуем его с помощью метода readable.\_read(): 
`
const Stream = require('stream')
const readableStream = new Stream.Readable()
`

Затем реализуем \_read: 
`
readableStream._read = () => {}
`

Реализовать \_read также можно посредством опции read: 
`
const readableStream = new Stream.Readable({
    read() {}
})
`

После этого мы можем помещать данные в поток: 
`
readableStream.push('hi!')
readableStream.push('ho!')
`

##### Как создать поток для записи?

Для создания потока для записи мы расширяем стандартный объект Writable и реализуем его метод \_write. 

Сначала мы создаем объект потока: 
`
const Stream = require('stream')
const writableStream = new Stream.Writable()
`

Затем реализуем \_write: 
`
writableStream._write = (chunk, encoding, next) => {
    console.log(chunk.toString())
    next()
}
`

После этого мы можем его туннелировать: 
`
process.stdin.pipe(writableStream)
`

##### Как получить данные из потока для чтения?

Данные из потока для чтения можно получить с помощью потока для записи: 

    const Stream = require('stream')

    const readableStream = new Stream.Readable({
        read() {}
    })
    const writableStream = new Stream.Writable()

    writableStream._write = (chunk, encoding, next) => {
        console.log(chunk.toString())
        next()
    }

    readableStream.pipe(writableStream)

    readableStream.push('hi!')
    readableStream.push('ho!')


Вы также можете читать поток напрямую, используя событие readable: 
`
readableStream.on('readable', () => {
    console.log(readableStream.read())
})
`

##### Как отправить данные в поток для записи?

Используйте метод write():
`
writableStream.write('hey!\n')
`

##### Как сообщить потоку для записи, что запись данных завершена?

Используйте метод end():

    const Stream = require('stream')

    const readableStream = new Stream.Readable({
        read() {}
    })
    const writableStream = new Stream.Writable()

    writableStream._write = (chunk, encoding, next) => {
        console.log(chunk.toString())
        next()
    }

    readableStream.pipe(writableStream)

    readableStream.push('hi!')
    readableStream.push('ho!')

    writableStream.end()

[anchor0]: https://nodejs.org/api/stream.html
