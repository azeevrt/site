### 31\. Асинхронность и функции обратного вызова

##### Асинхронность в языках программирования

Компьютеры являются асинхронными. 

Асинхронность означает, что вещи могу происходить независимо от основного потока программы. 

В современных компьютерах каждая программа запускается в определенное время, и затем ее выполнение останавливается, чтобы другая программа могла запуститься. Это происходит в цикле настолько быстро, что этого невозможно заметить. Нам кажется, что наши компьютеры выполняют несколько программ одновременно, но это всего лишь иллюзия (за исключением многопроцессорных компьютеров). 

Программы используют прерывание, сигнал, посылаемый процессору для привлечения внимания системы. 

Я не буду погружаться во внутренние процессы, но имейте ввиду, что программы, как правило, являются асинхронными, их выполнение откладывается для того, чтобы компьютер мог заняться другими делами. Когда программа ожидает ответа от сети, она не обращается к процессору до тех пор, пока запрос не будет завершен. 

Обычно, языки программирования являются синхронными, и некоторые из них предоставляют возможность управлять асинхронностью с помощью средств самого языка или специальных библиотек. C, Java, C\#, PHP, Go, Ruby, Swift и Python являются синхронными по умолчанию. Некоторые из них симулируют асинхронность, используя потоки для запуска новых процессов. 

##### JavaScript

JavaScript также является синхронным и однопоточным по умолчанию. Это означает, что код не может создавать новые потоки и выполняться параллельно. 

Строки кода выполняются последовательно, одна за другой, например:
`
const a = 1
    const b = 2
    const c = a * b 
    console.log(c)
    doSomething()
`

Однако JavaScript создавался для браузера, его основной задачей являлась мгновенная реакция на действия пользователя, такие как onClick, onMouseOver, onChange, onSubmit и т.д. Как он с этим справлялся, будучи синхронным? 

Все дело в среде выполнения. Браузер предоставляет такую возможность посредством набора прикладных интерфейсов, которые обеспечивают необходимый функционал. 

Спутся некоторое время, Node.js представил неблокирующий ввод/вывод, расширяющий эту концепция для доступа к файлам, взаимодействия с сетью и т.д. 

##### Функции обратного вызова

Вы не можете знать, когда пользователь нажмет на кнопку. Поэтому вы устанавливаете обработчик события "Клик". Этот обработчик принимает функцию, которая вызывается при возникновении события: 
`
document.getElementById('button').addEventListener('click', () => {
        // код 
    })
`

Эта функция называется колбеком (функцией обратного вызова). 

Колбек - это простая функция, которая передается в качестве аргумента другой функцией и выполняется только при возникновении события (обработчики событий - самый распространенный вариант замыкания). Мы можем это делать благодаря функциям первого класса, которые могут присваиваться переменным в качестве значений и передаваться другим функциям в качестве аргументов (эти функции также называются функциями высшего порядка). 

Обычной практикой является оборачивание клиентского кода в обработчик события load объекта window, запускающего колбек после полной загрузки страницы:
`
window.addEventListener('load', () => {
        // код 
    })
`

Колбеки используются повсеместно, не только для обработки событий DOM. 

Например, в счетчиках: 
`
setTimeout(() => {
        // запустить через 2 секунды
    }, 2000)
`

XHR-запросы также принимают колбек в качестве аргумента. В следующем примере функция присваивается в качестве свойства объекта и вызывается при возникновении определенного события (изменении состояния запроса):
`
const xhr = new XMLHttpRequest()
    xhr.onreadystatechange = () => {
        if (xhr.readyState === 4) {
            xhr.status === 200 ? console.log(xhr.responseText) : console.error('error')
        }
    }
    xhr.open('GET', 'https://yoursite.com')
    xhr.send()
`

##### Обработка ошибок в колбеках

Как обрабатывать ошибки в колбеках? Одним из способов является использование стратегии Node.js: первый аргумент любого колбека - это объект ошибки. 

Если ошибка отсутствует, объект равняется null. Если возникла ошибка, объект содержит ее описание и другую информацию. 

    fs.readFile('/file.json', (err, data) => {
            if (err !== null) {
                console.log(err)
                return
            }

            console.log(data)
        })

##### Проблема колбеков

Колбеки прекрасно подходят для простых случаев. 

Тем не менее, каждый колбек добавляет уровень вложенности, и при наличии множества колбеков, код очень быстро становится сложным для восприятия и поддержки: 
`
window.addEventListener('load', () => {
        document.getElementById('button').addEventListener('click', () => {
            setTimeout(() => {
                items.forEach(item => {
                    // и т.д.
                }, 2000)
            })
        })
    })
`

В приведенном примере всего 4 уровня вложенности, но я видел намного больше и это совсем не весело. 

Как нам решить эту проблему? 

##### Альтернатива колбекам

Начиная с ES6, JavaScript получил еще две возможности для работы с асинхронным кодом в дополнение к колбекам: промисы (ES6) и Async/Await (ES2017).

