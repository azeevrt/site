### 32\. Промисы

##### Введение

    let done = true 

    const isDoneYet = new Promise((resolve, reject) => {
        if (done) {
            const workDone = 'Here is the thing I build'
            resolve(workDone)
        } else {
            const why = 'Still working on something else'
            reject(why)
        }
    })

    const checkIfItsDone = () => {
        isItDoneYet 
            .then(ok => {
                console.log(ok)
            })
            .catch(err => {
                console.error(err)
            })
    }


Обычно, промис определяется как прокси для значения, которое будет доступно в будущем (promise - обещание). 

Промисы являются средством для работы с асинхронным кодом без использования колбеков. 

Промисы являются частью языка на протяжении многих лет (они были стандартизированы и представлены в ES2015 и оптимизированы в async/await в 2017 году). 

В основе асинхронных функций лежат промисы, поэтому понимание того, как они работают является основой для понимания того, как работает async/await. 

##### Как работают промисы?

Когда промис вызывается, начинается стадия ожидания. Это означает, что вызванная функция продолжает выполняться до разрешения промиса, возвращая запрошенные данные. 

Созданный промис завершается стадией выполнения или отклонения, что влечет за собой вызов колбека (переданного в then или catch). 

##### Какие прикладные интерфейсы используют промисы?

Промисы используются такими современными API, как:

* Battery
* Fetch
* Сервис-воркеры

Едва ли в современном JavaScript вам удастся обойтись без промисов, так что давайте рассмотрим их подробнее. 

##### Создание промиса

Promise API предоставляет конструктор промиса, который вызывается с помощью new Promise():

    let done = true

    const isItDoneYet = new Promise((resolve, reject) => {
        if (done) {
            const workDone = 'Here is the thing I built'
            resolve(workDone)
        } else {
            const why = 'Still working on something else'
            reject(why)
        }
    })

Как видите, промис проверяет глобальную константу done, и, если ее значением является true, промис выполняется (вызывается колбек resolve); иначе, вызывается колбек reject, промис отклоняется (если ни один из названных колбеков не будет вызван, промис останется в стадии ожидания). 

С помощью resolve и reject мы можем сообщать колбеку, каким было состояние промиса, и что с ним следует делать. В приведенном примере мы возвращали строку, но это может быть объект или null. В примере мы создаем промис таким способом, что он сразу начинает выполняться. Это важно для понимания раздела "Использование промиса" ниже. 

Более распространенным случаем использования промисов является так называемая промисификация. Эта техника заключается в использовании обычной функции, принимающей колбек, являющийся промисом:

    const fs = require('fs') 

    const getFile = filename => {
        return new Promise((resolve, reject) => {
            fs.readFile(filename, (err, data) => {
                if (err) {
                    reject(err) // 'reject' вызывается при отклонении промиса с или без ошибки, переданной в качестве аргумента,
                                // и мы не хотим двигаться дальше
                    return 
                }
                resolve(data) 
            })
        })
    }

    getFile('/etc/password')
        .then(data => console.log(data))
        .catch(err => console.error(err))

В последних версиях Node.js, вам не нужно делать промисификацию вручную для многих прикладных интерфейсов. Существует [модуль util][anchor0], который делает это за вас, обеспечивая возврат правильного значения промисифицируемой функции. 

##### Использование промиса

В предыдущем разделе мы рассмотрели, как создать промис. 

Теперь давайте посмотрим, как можно его использовать. 

    const isItDoneYet = new Promise(...)
    // ... 

    const checkIfItsDone = () => {
        isItDoneYet
            .then(ok => {
                console.log(ok)
            })
            .catch(err => {
                console.error(err)
            })
    }

В функции checkIfItsDone() определяются функции, запускаемые при выполнении промиса isItDoneYet (в колбеке then) или при его отклонении (в колбеке catch). 

##### Цепочка из промисов

Промисы могут возвращаться в качестве значений других промисов, формируя цепочки из промисов. 

Отличным примером цепочки промисов является Fetch API, который может использоваться для получения ресурса и работы с ним посредством очереди - цепочки из промисов. 

Fetch API - это механизм, основанный на промисах, и вызов fetch() эквивалентен созданию собственного промиса с помощью new Promise(): 

##### Пример цепочки промисов

    const status = response => {
        if (response.status >= 200 && response.status < 300) {
            return Promise.resolve(response)
        }
        return Promise.reject(new Error(response.statusText))
    }

    const json = response => response.json()

    fetch('/todos.json')
        .then(status)   // обратите внимание, что функция 'status' вызывается именно здесь и возвращает промис
        .then(json)     // единственным отличием является то, что функция 'json' возвращает промис, который разрешается 'data'
        .then(data => { // поэтому 'data' является первым параметром анонимной функции
            console.log('Request succeeded with JSON response ', data)
        })
        .catch(error => {
            console.log('Request failed ', error)
        })

В приведенном примере мы вызываем fetch() для получения списка задач из файла todos.json, находящегося в корневой директории, затем мы создаем цепочку промисов. 

Запуск fetch() возвращает [ответ][anchor1], имеющий много свойств, среди которых мы обращаемся к следующим: 

* status - числовое значение кода статуса HTTP-ответа
* statusText - статусное сообщение, например, OK в случае успешного запроса

response также имеет метод json(), который возвращает промис, выполняющийся с разобранным (распарсенным) содержимым тела ответа. 

С учетом изложенного, вот что происходит: первый промис в цепочке - это определенная нами функция status(), которая проверяет статус ответа, и, в случае, когда такой статус выходит за пределы диапазона 200-299, промис отклоняется. 

При отклонении промиса операция сразу переходит к блоку catch(), в консоль выводится текст Request failed и сообщение об ошибке. 

При успешном запросе вызывается функция json(). Поскольку предыдущий промис вернул объект response, мы получаем его в качестве параметра во втором промисе. 

Далее мы разбираем (парсим) ответ, так что третий промис получает данные в нужном формате:
`
.then(data => console.log('Request succeeded with JSON response ', data))
`

И мы просто выводим эти данные в консоль. 

##### Обработка ошибок

В примере у нас имелся блок catch в конце цепочки промисов. 

Когда что-либо в цепочке завершается с ошибкой или когда промис отклоняется, управление переходит к блюжайшему блоку catch. 

    new Promise((resolve, reject) => {
            throw new Error('Error')
        }).catch(err => {
            console.error(err)
        })
        
        // или
        
        new Promise((resolve, reject) => {
            reject('Error')
        }).catch(err => {
            console.error(err)
        })

##### Цепочка ошибок

Если в catch() вы получили ошибку, вы можете добавить второй catch() для ее обработки и т.д. 

    new Promise((resolve, reject) => {
            throw new Error('Error')
        })
        .catch(err => {
            throw new Error('Error')
        })
        .catch(err => {
            console.error(err)
        })

##### Оркестровка промисов

###### Promise.all()

Если вам необходимо синхронизировать разные промисы, Promise.all позволяет определить список промисов, и сделать что-либо после их выполнения.

Например:

    const f1 = fecth('/something.json')
    const f2 = fetch('/something2.json')

    Promise.all([f1, f2])
        .then(res => {
            console.log('Array of results ', res)
        })
        .catch(err => {
            console.error(err)
        })

С помощью деструктурирующего присваивания это можно сделать так: 
`
Promise.all([f1, f2]).then(([f1, f2]) => {
    console.log('Results ', res1, re2)
})
`

Разумеется, вы не ограничены fetch, в данном шаблоне проектирования могут использоваться любые промисы. 

###### Promise.race()

Promice.race() запускается при выполнении первого промиса, т.е. колбек промиса выполняется один раз с результатом первого выполненного промиса. 

Например: 

    const first = new Promise((resolve, reject) => {
        setTimeout(resolve, 500, 'first')
    })

    const second = new Promise((resolve, reject) => {
        setTimeout(resolve, 100, 'second')
    })

    Promise.race([first, second]).then(result => {
        console.log(result) // second
    })

##### Распространенные ошибки

###### Uncaught TypeError: undefined is not a promise

Если в консоли вы получили ошибку Uncaught TypeError: undefined is not a promise, убедитесь в том, что используете new Promise(), а не просто Promise(). 

###### UnhandledPromiseRejectionWarning

Это означает, что вызванный вами промис был отклонен, однако отсутствует блок catch для обработки возникшей ошибки. Добавьте catch в конец цепочки для решения этой проблемы.
\`

[anchor0]: https://nodejs.org/docs/latest-v11.x/api/util.html#util_util_promisify_original
[anchor1]: https://fetch.spec.whatwg.org/#concept-response

