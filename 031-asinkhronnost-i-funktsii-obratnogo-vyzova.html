<!DOCTYPE html>
<html lang="ru">
<head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
        <meta http-equiv="imagetoolbar" content="false">
        <link rel="preload" href="./theme/fonts/lato-v14-latin-300.woff2" as="font" type="font/woff2" /><!--  crossorigin  -->
        <link rel="preload" href="./theme/fonts/lato-v14-latin-700.woff2" as="font" type="font/woff2" /><!--  crossorigin  -->
        <link rel="preload" href="./theme/css/screen.css" as="style">
        <link rel="preload" href="./theme/css/user.css" as="style">

        <link rel="icon" type="image/x-icon" href="/favicon.ico">
        <title>031. Асинхронность и функции обратного вызова</title>

        <link rel="stylesheet" href="./theme/css/screen.css" />
        <link rel="stylesheet" href="./theme/css/user.css" />
        <!--[if lt IE 9]>
  <script src="./theme/js/html5shiv.min.js"></script>
  <script src="./theme/js/respond.min.js"></script>
  <![endif]-->
</head>

<body class="wrap js" id="page-top">
  <header>
    <div class="flexbox">
      <div class="center-on-mobiles">
        <h1>
          <a href="./" class="logo">
            <span class="sr-only">Azeevrt</span>
            <img src="./theme/img/logo-2x.png" width="140" height="65" alt="Azeevrt Logo">
          </a>
        </h1>
      </div>
      <nav class="main-nav hide-on-mobiles">
        <ul>
          <li>
              <a href="./category/azeevrt.html">Azeevrt</a>
          </li>
          <li class="active">
              <a href="./category/nodejs.html">Node.js</a>
          </li>
        </ul>
      </nav>
      <div class="meta hide-on-mobiles">
        <ul>
              <li><a href="https://azeevrt.github.io/site">Azeevrt /site/</a></li>
        </ul>
      </div>
    </div>
    <nav class="mobile-nav show-on-mobiles">
      <ul>
          <li>
              <a href="./category/azeevrt.html">Azeevrt</a>
          </li>
          <li class="active">
              <a href="./category/nodejs.html">Node.js</a>
          </li>
    </ul>
    </nav>
  </header>
    <section class="standalone">
      <div class="grid">
        <div class="unit whole">
          <article>
            <h3>31. Асинхронность и функции обратного вызова</h3>
<h5>Асинхронность в языках программирования</h5>
<p>Компьютеры являются асинхронными. </p>
<p>Асинхронность означает, что вещи могу происходить независимо от основного потока программы. </p>
<p>В современных компьютерах каждая программа запускается в определенное время, и затем ее выполнение останавливается, чтобы другая программа могла запуститься. Это происходит в цикле настолько быстро, что этого невозможно заметить. Нам кажется, что наши компьютеры выполняют несколько программ одновременно, но это всего лишь иллюзия (за исключением многопроцессорных компьютеров). </p>
<p>Программы используют прерывание, сигнал, посылаемый процессору для привлечения внимания системы. </p>
<p>Я не буду погружаться во внутренние процессы, но имейте ввиду, что программы, как правило, являются асинхронными, их выполнение откладывается для того, чтобы компьютер мог заняться другими делами. Когда программа ожидает ответа от сети, она не обращается к процессору до тех пор, пока запрос не будет завершен. </p>
<p>Обычно, языки программирования являются синхронными, и некоторые из них предоставляют возможность управлять асинхронностью с помощью средств самого языка или специальных библиотек. C, Java, C#, PHP, Go, Ruby, Swift и Python являются синхронными по умолчанию. Некоторые из них симулируют асинхронность, используя потоки для запуска новых процессов. </p>
<h5>JavaScript</h5>
<p>JavaScript также является синхронным и однопоточным по умолчанию. Это означает, что код не может создавать новые потоки и выполняться параллельно. </p>
<p>Строки кода выполняются последовательно, одна за другой, например:</p>
<div class="highlight"><pre><span></span><span class="err">const a = 1</span>
<span class="err">const b = 2</span>
<span class="err">const c = a * b </span>
<span class="err">console.log(c)</span>
<span class="err">doSomething()</span>
</pre></div>


<p>Однако JavaScript создавался для браузера, его основной задачей являлась мгновенная реакция на действия пользователя, такие как onClick, onMouseOver, onChange, onSubmit и т.д. Как он с этим справлялся, будучи синхронным? </p>
<p>Все дело в среде выполнения. Браузер предоставляет такую возможность посредством набора прикладных интерфейсов, которые обеспечивают необходимый функционал. </p>
<p>Спутся некоторое время, Node.js представил неблокирующий ввод/вывод, расширяющий эту концепция для доступа к файлам, взаимодействия с сетью и т.д. </p>
<h5>Функции обратного вызова</h5>
<p>Вы не можете знать, когда пользователь нажмет на кнопку. Поэтому вы устанавливаете обработчик события "Клик". Этот обработчик принимает функцию, которая вызывается при возникновении события: </p>
<div class="highlight"><pre><span></span><span class="err">document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, () =&gt; {</span>
<span class="err">        // код </span>
<span class="err">})</span>
</pre></div>


<p>Эта функция называется колбеком (функцией обратного вызова). </p>
<p>Колбек - это простая функция, которая передается в качестве аргумента другой функцией и выполняется только при возникновении события (обработчики событий - самый распространенный вариант замыкания). Мы можем это делать благодаря функциям первого класса, которые могут присваиваться переменным в качестве значений и передаваться другим функциям в качестве аргументов (эти функции также называются функциями высшего порядка). </p>
<p>Обычной практикой является оборачивание клиентского кода в обработчик события load объекта window, запускающего колбек после полной загрузки страницы:</p>
<div class="highlight"><pre><span></span><span class="err">window.addEventListener(&#39;load&#39;, () =&gt; {</span>
<span class="err">        // код </span>
<span class="err">})</span>
</pre></div>


<p>Колбеки используются повсеместно, не только для обработки событий DOM. </p>
<p>Например, в счетчиках: </p>
<div class="highlight"><pre><span></span><span class="err">setTimeout(() =&gt; {</span>
<span class="err">        // запустить через 2 секунды</span>
<span class="err">}, 2000)</span>
</pre></div>


<p>XHR-запросы также принимают колбек в качестве аргумента. В следующем примере функция присваивается в качестве свойства объекта и вызывается при возникновении определенного события (изменении состояния запроса):</p>
<div class="highlight"><pre><span></span><span class="err">const xhr = new XMLHttpRequest()</span>
<span class="err">xhr.onreadystatechange = () =&gt; {</span>
<span class="err">    if (xhr.readyState === 4) {</span>
<span class="err">        xhr.status === 200 ? console.log(xhr.responseText) : console.error(&#39;error&#39;)</span>
<span class="err">    }</span>
<span class="err">}</span>
<span class="err">xhr.open(&#39;GET&#39;, &#39;https://yoursite.com&#39;)</span>
<span class="err">xhr.send()</span>
</pre></div>


<h5>Обработка ошибок в колбеках</h5>
<p>Как обрабатывать ошибки в колбеках? Одним из способов является использование стратегии Node.js: первый аргумент любого колбека - это объект ошибки. </p>
<p>Если ошибка отсутствует, объект равняется null. Если возникла ошибка, объект содержит ее описание и другую информацию. </p>
<div class="highlight"><pre><span></span><span class="n">fs</span><span class="p">.</span><span class="n">readFile</span><span class="p">(</span><span class="s1">&#39;/file.json&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="err">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="err">{</span>
        <span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="err">}</span>

    <span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
<span class="err">}</span><span class="p">)</span>
</pre></div>


<h5>Проблема колбеков</h5>
<p>Колбеки прекрасно подходят для простых случаев. </p>
<p>Тем не менее, каждый колбек добавляет уровень вложенности, и при наличии множества колбеков, код очень быстро становится сложным для восприятия и поддержки: </p>
<div class="highlight"><pre><span></span><span class="err">window.addEventListener(&#39;load&#39;, () =&gt; {</span>
<span class="err">    document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, () =&gt; {</span>
<span class="err">        setTimeout(() =&gt; {</span>
<span class="err">            items.forEach(item =&gt; {</span>
<span class="err">                // и т.д.</span>
<span class="err">            }, 2000)</span>
<span class="err">        })</span>
<span class="err">    })</span>
<span class="err">})</span>
</pre></div>


<p>В приведенном примере всего 4 уровня вложенности, но я видел намного больше и это совсем не весело. </p>
<p>Как нам решить эту проблему? </p>
<h5>Альтернатива колбекам</h5>
<p>Начиная с ES6, JavaScript получил еще две возможности для работы с асинхронным кодом в дополнение к колбекам: промисы (ES6) и Async/Await (ES2017).</p>

          </article><!-- /#posts-list -->
        </div>
        <div class="clear"></div>
      </div>
    </section>
<footer>
  <div class="grid">
    <div class="unit one-third center-on-mobiles">
  <h2>Р</h2>
    <ul class="inline-block text align-center list">
          <li> — <a href="https://github.com/azeevrt/site.git" target="_top">репозиторий</a></li>
    </ul><!-- /.blogroll -->
    </div>
    <div class="unit two-thirds align-right center-on-mobiles">
      <p>
        Гордо принимает 
        <a href="https://github.com">
          <img src="./theme/img/footer-logo.png" width="100" height="30" alt="GitHub • Социальное программирование">
        </a>
      </p>
      <h2>A</h2>
        <ul class="inline-block text align-center list">
                <li> — <a href="https://azeevrt.github.io/site">Azeevrt /site/</a></li>
        </ul><!-- /.social -->
    </div>
  </div>
</footer>
<a class="scroll-to-top rounded js-scroll-trigger button" href="#"><i class="fas fa-angle-up"></i></a>
<script src="./theme/js/jquery-2.2.4.min.js"></script>
<script type="text/javascript">
    // Smooth scrolling using jQuery easing
    $('a.js-scroll-trigger[href*="#"]:not([href="#"])').click(function() {
      if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
        if (target.length) {
          $('html, body').animate({
            scrollTop: target.offset().top
          }, 1000, "easeInOutExpo");
          return false;
        }
      }
    });


     $('.akkordeon').on('click', 'h2, h3, h4, strong', function () {
        var akk = $(this).parent().parent();
        var action;
        (!akk.attr('open')) ? action = 'expand': action = 'reduce';
        var section = 'page.module.part.' + action;

    });
</script>
</body>
</html>