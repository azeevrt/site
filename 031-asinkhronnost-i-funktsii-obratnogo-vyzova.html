<!DOCTYPE html>
<html lang="ru">
<head>
        <meta charset="utf-8" />
        <title>031. Асинхронность и функции обратного вызова</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
        <meta http-equiv="imagetoolbar" content="false">
        <link rel="stylesheet" href="./theme/products.css" />
</head>

<body id="page-top" class=" js">
  <div class="grid">
    <header id="header" class="l-12 l-fix center vline header">
      <strong><i style="display: none;"></i><a href="./">Azeevrt</a> <i style="font-size: 0.5em">For everyone and for me</i></strong>

      <!-- 

      <strong><a href="#">Azeervt</a>
          <a href="/mail/">Email</a></strong>
        -->
      <div class="module left l-0 m-1 s-1 fix">
        <span class="l s-0 white service-light-hover burger icon service-light" data-toggle-nodes="body{toggle-nav},
        .header .service-light-hover.burger.icon{service-light}" tabindex="0">Show/hide navigation</span>
        <span class="l m-0 white service-light-hover burger icon service-light" data-toggle-nodes="body{toggle-nav},
      .header .service-light-hover.burger.icon{service-light}" tabindex="0">Show/hide navigation</span>
      </div>
      <div class="container right l-1 fix">
        <div class="module l-1 fix left align-center">
        <!--
        <a data-tracking-contentposition="header.icon.login" class="l s-0 white service-light-hover show-text person icon" href="#" aria-label="Login"></a>

        <a data-tracking-contentposition="header.icon.login" class="l l-0 m-0  white person icon" href="#" aria-label="Login"></a>
        -->
        </div>
      </div>
    </header>
    <nav class="fullwidth center navigation">
        <ul class="l-12 fix">
          <li><a href="./" data-title="Azeevrt">
              <span class="l l-0 service home icon"></span>
              <span class="m s-0 m-0 inactive service-hover home icon"></span></a>
              <span class="l-0 m inactive service-hover close icon" data-unset-nodes="body{toggle-nav}, .header .burger.icon{service}"></span>
          </li>
          <!-- <li>
            <span data-hide-nodes="span[data-hide-parent]{current}" data-hide-parent=".navigation > ul > li" data-toggle-nodes=".navigation span.current{open}, .navigation span:not(.current).open{open}, .navigation .current{current}">
              Навигация
                <span class="m-0 s-0 s inactive down icon"></span>
                <span class="l-0 m inactive down icon"></span>
                <span class="m-0 s-0 s service down icon"></span>
                <span class="l-0 m service down icon"></span>
                <span class="m-0 s-0 s white up icon"></span>
            </span>
             
          </li> -->
              <li>
                  <a href="./category/azeevrt.html">Azeevrt</a>

                 
              </li>
              <li class="active">
                  <a href="./category/nodejs.html">Node.js</a>

                 
              </li>
      </ul>
    </nav>
    
    <div class="container l-12 center ">
      <div class="container l-12 fix">
          <div class="container l-12 fix group-headline">
              <h2 class="size-7 module l-12 fix align-center">031. Асинхронность и функции обратного вызова</h2>
<footer class="post-info">
        <abbr class="published" title="2020-08-10T18:00:09+02:00">
                Published: Пн 10 Август 2020
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="./author/vrt.html">VRT</a>
        </address>
<p>In <a href="./category/nodejs.html">Node.js</a>.</p>

</footer><!-- /.post-info -->          </div>
          <div class="module l-12 fix vspace-s">                                
              <h3>31. Асинхронность и функции обратного вызова</h3>
<h5>Асинхронность в языках программирования</h5>
<p>Компьютеры являются асинхронными. </p>
<p>Асинхронность означает, что вещи могу происходить независимо от основного потока программы. </p>
<p>В современных компьютерах каждая программа запускается в определенное время, и затем ее выполнение останавливается, чтобы другая программа могла запуститься. Это происходит в цикле настолько быстро, что этого невозможно заметить. Нам кажется, что наши компьютеры выполняют несколько программ одновременно, но это всего лишь иллюзия (за исключением многопроцессорных компьютеров). </p>
<p>Программы используют прерывание, сигнал, посылаемый процессору для привлечения внимания системы. </p>
<p>Я не буду погружаться во внутренние процессы, но имейте ввиду, что программы, как правило, являются асинхронными, их выполнение откладывается для того, чтобы компьютер мог заняться другими делами. Когда программа ожидает ответа от сети, она не обращается к процессору до тех пор, пока запрос не будет завершен. </p>
<p>Обычно, языки программирования являются синхронными, и некоторые из них предоставляют возможность управлять асинхронностью с помощью средств самого языка или специальных библиотек. C, Java, C#, PHP, Go, Ruby, Swift и Python являются синхронными по умолчанию. Некоторые из них симулируют асинхронность, используя потоки для запуска новых процессов. </p>
<h5>JavaScript</h5>
<p>JavaScript также является синхронным и однопоточным по умолчанию. Это означает, что код не может создавать новые потоки и выполняться параллельно. </p>
<p>Строки кода выполняются последовательно, одна за другой, например:</p>
<div class="highlight"><pre><span></span><span class="err">const a = 1</span>
<span class="err">const b = 2</span>
<span class="err">const c = a * b </span>
<span class="err">console.log(c)</span>
<span class="err">doSomething()</span>
</pre></div>


<p>Однако JavaScript создавался для браузера, его основной задачей являлась мгновенная реакция на действия пользователя, такие как onClick, onMouseOver, onChange, onSubmit и т.д. Как он с этим справлялся, будучи синхронным? </p>
<p>Все дело в среде выполнения. Браузер предоставляет такую возможность посредством набора прикладных интерфейсов, которые обеспечивают необходимый функционал. </p>
<p>Спутся некоторое время, Node.js представил неблокирующий ввод/вывод, расширяющий эту концепция для доступа к файлам, взаимодействия с сетью и т.д. </p>
<h5>Функции обратного вызова</h5>
<p>Вы не можете знать, когда пользователь нажмет на кнопку. Поэтому вы устанавливаете обработчик события "Клик". Этот обработчик принимает функцию, которая вызывается при возникновении события: </p>
<div class="highlight"><pre><span></span><span class="err">document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, () =&gt; {</span>
<span class="err">        // код </span>
<span class="err">})</span>
</pre></div>


<p>Эта функция называется колбеком (функцией обратного вызова). </p>
<p>Колбек - это простая функция, которая передается в качестве аргумента другой функцией и выполняется только при возникновении события (обработчики событий - самый распространенный вариант замыкания). Мы можем это делать благодаря функциям первого класса, которые могут присваиваться переменным в качестве значений и передаваться другим функциям в качестве аргументов (эти функции также называются функциями высшего порядка). </p>
<p>Обычной практикой является оборачивание клиентского кода в обработчик события load объекта window, запускающего колбек после полной загрузки страницы:</p>
<div class="highlight"><pre><span></span><span class="err">window.addEventListener(&#39;load&#39;, () =&gt; {</span>
<span class="err">        // код </span>
<span class="err">})</span>
</pre></div>


<p>Колбеки используются повсеместно, не только для обработки событий DOM. </p>
<p>Например, в счетчиках: </p>
<div class="highlight"><pre><span></span><span class="err">setTimeout(() =&gt; {</span>
<span class="err">        // запустить через 2 секунды</span>
<span class="err">}, 2000)</span>
</pre></div>


<p>XHR-запросы также принимают колбек в качестве аргумента. В следующем примере функция присваивается в качестве свойства объекта и вызывается при возникновении определенного события (изменении состояния запроса):</p>
<div class="highlight"><pre><span></span><span class="err">const xhr = new XMLHttpRequest()</span>
<span class="err">xhr.onreadystatechange = () =&gt; {</span>
<span class="err">    if (xhr.readyState === 4) {</span>
<span class="err">        xhr.status === 200 ? console.log(xhr.responseText) : console.error(&#39;error&#39;)</span>
<span class="err">    }</span>
<span class="err">}</span>
<span class="err">xhr.open(&#39;GET&#39;, &#39;https://yoursite.com&#39;)</span>
<span class="err">xhr.send()</span>
</pre></div>


<h5>Обработка ошибок в колбеках</h5>
<p>Как обрабатывать ошибки в колбеках? Одним из способов является использование стратегии Node.js: первый аргумент любого колбека - это объект ошибки. </p>
<p>Если ошибка отсутствует, объект равняется null. Если возникла ошибка, объект содержит ее описание и другую информацию. </p>
<div class="highlight"><pre><span></span><span class="n">fs</span><span class="p">.</span><span class="n">readFile</span><span class="p">(</span><span class="s1">&#39;/file.json&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="err">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="err">{</span>
        <span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="err">}</span>

    <span class="n">console</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="k">data</span><span class="p">)</span>
<span class="err">}</span><span class="p">)</span>
</pre></div>


<h5>Проблема колбеков</h5>
<p>Колбеки прекрасно подходят для простых случаев. </p>
<p>Тем не менее, каждый колбек добавляет уровень вложенности, и при наличии множества колбеков, код очень быстро становится сложным для восприятия и поддержки: </p>
<div class="highlight"><pre><span></span><span class="err">window.addEventListener(&#39;load&#39;, () =&gt; {</span>
<span class="err">    document.getElementById(&#39;button&#39;).addEventListener(&#39;click&#39;, () =&gt; {</span>
<span class="err">        setTimeout(() =&gt; {</span>
<span class="err">            items.forEach(item =&gt; {</span>
<span class="err">                // и т.д.</span>
<span class="err">            }, 2000)</span>
<span class="err">        })</span>
<span class="err">    })</span>
<span class="err">})</span>
</pre></div>


<p>В приведенном примере всего 4 уровня вложенности, но я видел намного больше и это совсем не весело. </p>
<p>Как нам решить эту проблему? </p>
<h5>Альтернатива колбекам</h5>
<p>Начиная с ES6, JavaScript получил еще две возможности для работы с асинхронным кодом в дополнение к колбекам: промисы (ES6) и Async/Await (ES2017).</p>
          </div>
          <div class="module l-12 fix vspace-s">
          </div>
      </div>
  </div>

    <footer id="footer">
      <div class="container l-12 backdrop-c2-light50 inverted vspace-s">
        <div class="container l-12 fix center">
        	<h2>Р</h2>
	          <ul class="inline-block text align-center list">
	                <li><a href="https://github.com/azeevrt/site.git" target="_top">репозиторий</a></li>
	          </ul><!-- /.blogroll -->
          	<h2>A</h2>
	          <ul class="inline-block text align-center list">
                    <li><a href="https://azeevrt.github.io/site">Azeevrt /site/</a></li>
	          </ul><!-- /.social -->
        </div>
      </div>
    </footer>
    <a class="scroll-to-top rounded js-scroll-trigger button" href="#">
      <i class="fas fa-angle-up"></i>
    </a>
  </div>

<!--    -->


<script src="./theme/products.js"></script>
<script src="./theme/jquery-2.2.4.min.js"></script>

<script type="text/javascript">


    // Smooth scrolling using jQuery easing
    $('a.js-scroll-trigger[href*="#"]:not([href="#"])').click(function() {
      if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
        if (target.length) {
          $('html, body').animate({
            scrollTop: target.offset().top
          }, 1000, "easeInOutExpo");
          return false;
        }
      }
    });

    // Scroll to top button appear
    $(document).scroll(function() {
      var scrollDistance = $(this).scrollTop();
      if (scrollDistance > 100) {
        $('.scroll-to-top').fadeIn();
      } else {
        $('.scroll-to-top').fadeOut();
      }
    });

    $('.akkordeon').on('click', 'h2, h3, h4, strong', function () {
        var akk = $(this).parent().parent();
        var action;
        (!akk.attr('open')) ? action = 'expand': action = 'reduce';
        var section = 'page.module.part.' + action;

    });

    $('span.link-base:not([data-hide-nodes=""])').on('click', function () {
        var expandable = $(this);
        var count = expandable.closest('[data-tracking-count]').data('tracking-count');
        var eventposition = expandable.closest('[data-tracking-eventposition]').data('tracking-eventposition');
        var contentposition = expandable.closest('[data-tracking-contentposition]').data('tracking-contentposition');

        trackExpandable('page.module.part.expand', count, eventposition, contentposition);
    });

    $('span.close:not([data-hide-nodes=""])').on('click', function () {
        var expandable = $(this);
        if(expandable.closest('[data-tracking-count]').data('tracking-count') !== 2) {
            var count = expandable.closest('[data-tracking-count]').data('tracking-count');
            var eventposition = expandable.closest('[data-tracking-eventposition]').data('tracking-eventposition');
            var contentposition = expandable.closest('[data-tracking-contentposition]').data('tracking-contentposition');

            trackExpandable('page.module.part.reduce', count, eventposition, contentposition);
        }
    });

    $('.navigation > ul > li[data-unset-nodes="#empty"] span').on('click', function () {
        var navExpandable = $(this);
        var navAction;
        (!navExpandable.hasClass('open')) ? navAction = 'expand' : navAction = 'reduce';
        var section = 'page.navigation.' + navAction;
        var count = navExpandable.closest('[data-tracking-count]').data('tracking-count');
        var eventposition = navExpandable.closest('[data-tracking-eventposition]').data('tracking-eventposition');
        var contentposition = navExpandable.closest('[data-tracking-contentposition]').data('tracking-contentposition');

        trackExpandable(section, count, eventposition, contentposition);
    });

    // home-button, screenSize < 980px
    $('.header > div > span').on('click', function () {
        var navExpandable = $(this);
        var navAction;
        (!navExpandable.hasClass('service')) ? navAction = 'expand': navAction = 'reduce';
        var section = 'page.navigation.home.' + navAction;

        trackExpandable(section, 2, 2, 'header.menu');
    });

    $('.navigation > ul > li span.close.icon').on('click', function () {
        trackExpandable('page.navigation.home.reduce', 2, 2, 'header.menu');
    });

</script>
</body>
</html>